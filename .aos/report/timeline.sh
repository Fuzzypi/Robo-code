#!/bin/bash
# timeline.sh - Generate a human-readable timeline report for a job
#
# BEHAVIOR:
#   - Reads from .aos/logs/evlog.ndjson (read-only)
#   - Generates a markdown report at .aos/reports/timeline_<job_id>_<timestamp>.md
#   - NEVER modifies the log file
#   - Fails gracefully if log doesn't exist (produces "no data" report)
#   - Exit 0 even on missing data
#
# USAGE:
#   ./timeline.sh [job_id]       # Generate report for specific job
#   ./timeline.sh                # Use current job from state, or UNKNOWN
#   ./timeline.sh -h             # Show help
#
# EXAMPLES:
#   ./timeline.sh AOS__PHASE4_TEST
#   ./timeline.sh
#
# OUTPUT:
#   Creates: .aos/reports/timeline_<job_id>_<YYYYMMDD_HHMMSS>.md

set -e

# Determine directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
AOS_DIR="$(dirname "$SCRIPT_DIR")"
EVLOG_FILE="${AOS_DIR}/logs/evlog.ndjson"
STATE_FILE="${AOS_DIR}/state/current_job.json"
REPORTS_DIR="${AOS_DIR}/reports"

# Parse arguments
show_help() {
    echo "timeline.sh - Generate a human-readable timeline report"
    echo ""
    echo "Usage: ./timeline.sh [OPTIONS] [job_id]"
    echo ""
    echo "Options:"
    echo "  -h       Show this help message"
    echo ""
    echo "Arguments:"
    echo "  job_id   The job ID to report on (optional)"
    echo "           If omitted, reads from current_job.json or uses UNKNOWN"
    echo ""
    echo "Output:"
    echo "  Creates .aos/reports/timeline_<job_id>_<timestamp>.md"
    echo ""
    echo "Examples:"
    echo "  ./timeline.sh AOS__PHASE4_TEST"
    echo "  ./timeline.sh"
    exit 0
}

JOB_ID=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        *)
            if [ -z "$JOB_ID" ]; then
                JOB_ID="$1"
            fi
            shift
            ;;
    esac
done

# Determine job_id if not provided
if [ -z "$JOB_ID" ]; then
    if [ -f "$STATE_FILE" ]; then
        JOB_ID=$(jq -r '.job_id // "UNKNOWN"' "$STATE_FILE" 2>/dev/null || echo "UNKNOWN")
    else
        JOB_ID="UNKNOWN"
    fi
fi

# Generate timestamp for filename
REPORT_TS="$(date +"%Y%m%d_%H%M%S")"
REPORT_FILE="${REPORTS_DIR}/timeline_${JOB_ID}_${REPORT_TS}.md"

# Ensure reports directory exists
mkdir -p "${REPORTS_DIR}"

# Generate report function
generate_report() {
    local evlog_exists=$1

    # Header
    echo "# Timeline Report: ${JOB_ID}"
    echo ""
    echo "**Generated:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    echo ""

    if [ "$evlog_exists" = "false" ]; then
        echo "## Status: No Data"
        echo ""
        echo "> evlog.ndjson not found or empty. No events to report."
        echo ""
        echo "---"
        echo "*Report generated by AOS timeline.sh*"
        return
    fi

    # Filter events for this job
    EVENTS=$(jq -c "select(.job_id == \"$JOB_ID\")" "$EVLOG_FILE" 2>/dev/null)

    if [ -z "$EVENTS" ]; then
        echo "## Status: No Events"
        echo ""
        echo "> No events found for job ID: \`${JOB_ID}\`"
        echo ""
        echo "---"
        echo "*Report generated by AOS timeline.sh*"
        return
    fi

    # Get repo and branch from first event
    REPO=$(echo "$EVENTS" | head -1 | jq -r '.repo // "unknown"')
    BRANCH=$(echo "$EVENTS" | head -1 | jq -r '.branch // "unknown"')

    # Time range
    FIRST_TS=$(echo "$EVENTS" | head -1 | jq -r '.timestamp // "unknown"')
    LAST_TS=$(echo "$EVENTS" | tail -1 | jq -r '.timestamp // "unknown"')

    # Header info
    echo "## Job Metadata"
    echo ""
    echo "| Field | Value |"
    echo "|-------|-------|"
    echo "| **Job ID** | \`${JOB_ID}\` |"
    echo "| **Repository** | ${REPO} |"
    echo "| **Branch** | ${BRANCH} |"
    echo "| **Start Time** | ${FIRST_TS} |"
    echo "| **End Time** | ${LAST_TS} |"
    echo ""

    # Statistics
    TOTAL=$(echo "$EVENTS" | wc -l | tr -d ' ')
    SUCCESS_COUNT=$(echo "$EVENTS" | jq -c 'select(.result == "success")' | wc -l | tr -d ' ')
    FAILURE_COUNT=$(echo "$EVENTS" | jq -c 'select(.result == "failure")' | wc -l | tr -d ' ')

    echo "## Summary"
    echo ""
    echo "- **Total Events:** ${TOTAL}"
    echo "- **Successful:** ${SUCCESS_COUNT}"
    echo "- **Failed:** ${FAILURE_COUNT}"
    echo ""

    # Chronological events
    echo "## Chronological Events"
    echo ""
    echo "$EVENTS" | while IFS= read -r line; do
        ts=$(echo "$line" | jq -r '.timestamp // "?"')
        action=$(echo "$line" | jq -r '.action_type // "?"')
        desc=$(echo "$line" | jq -r '.description // "no description"')
        result=$(echo "$line" | jq -r '.result // "?"')
        agent=$(echo "$line" | jq -r '.agent_role // "?"')

        case "$result" in
            success) icon="âœ…" ;;
            failure) icon="âŒ" ;;
            started) icon="ðŸ”„" ;;
            aborted) icon="âš ï¸" ;;
            *) icon="â“" ;;
        esac

        echo "### ${icon} ${ts}"
        echo ""
        echo "- **Action:** ${action}"
        echo "- **Agent:** ${agent}"
        echo "- **Result:** ${result}"
        echo "- **Description:** ${desc}"
        echo ""
    done

    # Commands section (filter action_type == command)
    COMMANDS=$(echo "$EVENTS" | jq -c 'select(.action_type == "command")')
    if [ -n "$COMMANDS" ]; then
        echo "## Commands Executed"
        echo ""
        echo "| Timestamp | Command/Description | Exit Code | Duration |"
        echo "|-----------|---------------------|-----------|----------|"
        echo "$COMMANDS" | while IFS= read -r line; do
            ts=$(echo "$line" | jq -r '.timestamp // "?"')
            desc=$(echo "$line" | jq -r '.description // "?"')
            cmd=$(echo "$line" | jq -r '.command // ""')
            exit_code=$(echo "$line" | jq -r '.exit_code // "-"')
            duration=$(echo "$line" | jq -r '.duration_ms // "-"')

            # Use command if available, otherwise description
            display="${cmd:-$desc}"
            # Escape pipes for markdown table
            display=$(echo "$display" | sed 's/|/\\|/g')
            # Truncate if too long
            if [ ${#display} -gt 50 ]; then
                display="${display:0:47}..."
            fi

            if [ "$duration" != "-" ] && [ "$duration" != "null" ]; then
                duration="${duration}ms"
            fi
            if [ "$exit_code" = "null" ]; then
                exit_code="-"
            fi

            echo "| ${ts} | \`${display}\` | ${exit_code} | ${duration} |"
        done
        echo ""
    fi

    # Artifacts section (deduplicated)
    ARTIFACTS=$(echo "$EVENTS" | jq -r '.artifacts[]?' 2>/dev/null | sort | uniq)
    if [ -n "$ARTIFACTS" ]; then
        echo "## Artifacts Referenced"
        echo ""
        echo "$ARTIFACTS" | while IFS= read -r artifact; do
            if [ -n "$artifact" ]; then
                echo "- \`${artifact}\`"
            fi
        done
        echo ""
    fi

    # Failures section (non-success results)
    FAILURES=$(echo "$EVENTS" | jq -c 'select(.result == "failure" or .result == "aborted")')
    if [ -n "$FAILURES" ]; then
        echo "## Failures"
        echo ""
        echo "| Timestamp | Action | Description |"
        echo "|-----------|--------|-------------|"
        echo "$FAILURES" | while IFS= read -r line; do
            ts=$(echo "$line" | jq -r '.timestamp // "?"')
            action=$(echo "$line" | jq -r '.action_type // "?"')
            desc=$(echo "$line" | jq -r '.description // "?"')
            # Escape pipes
            desc=$(echo "$desc" | sed 's/|/\\|/g')
            echo "| ${ts} | ${action} | ${desc} |"
        done
        echo ""
    else
        echo "## Failures"
        echo ""
        echo "> No failures recorded for this job."
        echo ""
    fi

    echo "---"
    echo "*Report generated by AOS timeline.sh*"
}

# Check if evlog exists and has content
EVLOG_EXISTS="true"
if [ ! -f "$EVLOG_FILE" ]; then
    EVLOG_EXISTS="false"
elif [ ! -s "$EVLOG_FILE" ]; then
    EVLOG_EXISTS="false"
fi

# Generate the report
generate_report "$EVLOG_EXISTS" > "$REPORT_FILE"

# Output confirmation
echo "Timeline report generated:"
echo "  Job ID: ${JOB_ID}"
echo "  Report: ${REPORT_FILE}"

# Exit successfully (even if no data)
exit 0
